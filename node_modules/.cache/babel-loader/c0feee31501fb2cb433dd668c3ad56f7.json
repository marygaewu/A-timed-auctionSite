{"ast":null,"code":"var _jsxFileName = \"/home/zetsuboii/dev/react/reach-react-template/src/components/participants/User.js\";\nimport { Component } from \"react\";\nimport UserViews from \"./UserViews\";\nimport * as Backend from \"../../build/index.main.mjs\";\nimport { Context } from \"../../Context\";\n/**\n * @dev Buradaki User benim yazmış olduğum reachStorage kontratındaki bir\n * katılımcı. Sizin de yazdığınız kontratlardaki katılımcılara göre birden\n * fazla bu şekilde class bulundurmanız gerekli. \n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class User extends Component {\n  // Context'te tutulan bilgileri al.\n  constructor(props) {\n    super(props);\n    /**\n     * @dev Kullanıcıdan her input bekleyişimizde bir Promise yapısı \n     * kullanacağımızdan her değer isteyen kontrat fonksiyonu için bir resolve\n     * fonksiyonunun state'de bulunması gerekli.\n     * \n     * @param appState: Kontratın hangi fonksiyonu çağırdığını gösterir\n     * @param args: Bu fonksiyonu çağırırken gönderilen argümanlar\n     * @param resUseCommand: useCommand appState'inin resolve fonksiyonu\n     */\n\n    this.state = {\n      appState: \"\",\n      args: [],\n      resUseCommand: null\n    };\n    this.useCommand = this.useCommand.bind(this);\n    this.useCommandExt = this.useCommandExt.bind(this);\n  }\n\n  componentDidMount() {\n    // Kontratı Context'ten al ve kontrattaki User'ın bu class\n    // olduğunu belirt.\n    const [,,,,,, ctc] = this.context;\n    Backend.User(ctc[0], this);\n  }\n  /**\n   * @dev Burada bir Promise örüntüsü kullanılmakta.\n   * Reach useCommand fonksiyonunu dışarıdan çağırdığında veri girişi\n   * olana kadar bir şey döndürmemek istiyoruz.\n   * \n   * Bu yüzden de await new Promise() ile fonksiyonu bir nevi donduruyoruz.\n   * new Promise(resolve => {...}) şeklinde yazılan bir fonksiyondan değer\n   * dönmesi için resolve'un çağırılması gerekli.\n   * \n   * Bunun için de resolve'u state'e yükleyerek UserViews'a aktarıyoruz ve\n   * orada kullanıcıdan input alarak resolve'u çağırıyoruz.\n   * \n   * Burada useCommand Reach'in çağıracağı kontratta belirlenen fonksiyon\n   * useCommandExt de bizim resolve'u tetiklemek için çağıracağımız fonksiyon.\n   * \n   * O yüzden useCommand state'e gidecek, useCommandExt de UserViews'a\n   * \n   */\n\n\n  async useCommand() {\n    const command = await new Promise(res => {\n      console.log(\"useCommand is called\");\n      this.setState({\n        appState: \"useCommand\",\n        resUseCommand: res\n      });\n    });\n    console.log(command);\n    return command;\n  }\n\n  useCommandExt(command) {\n    console.log(\"useCommandExt is called\");\n    this.state.resUseCommand(command);\n  }\n  /**\n   * \n   * @param {int} value Reach'in seeValue'yu çağırırken bize \n   * vereceği değer\n   * \n   * Eğer bizden input beklemeyen bir fonksiyon varsa doğrudan\n   * appState'i değiştirmemiz ve gelen argümanları state'de\n   * args listesinde eklememiz yeterli. \n   */\n\n\n  async seeValue(value) {\n    this.setState({\n      appState: \"seeValue\",\n      args: [value]\n    });\n  }\n\n  async valueChanged(value, user) {\n    this.setState({\n      appState: \"seeValueChanged\",\n      args: [value, user]\n    });\n  }\n  /**\n   * \n   * @dev UserViews gelen appState değerine göre farklı bir view döndürmeli\n   * Her input bekleyen Reach fonksiyonu için bir ready boolean'ı ve bir\n   * de onu resolve'u çağıran bir fonksiyon UserViews'a yollanmalı \n   */\n\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(UserViews, {\n      appState: this.state.appState,\n      args: this.state.args,\n      useCommandReady: this.state.resUseCommand != null,\n      useCommand: this.useCommandExt\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 17\n    }, this);\n  }\n\n}\nUser.contextType = Context;","map":{"version":3,"sources":["/home/zetsuboii/dev/react/reach-react-template/src/components/participants/User.js"],"names":["Component","UserViews","Backend","Context","User","constructor","props","state","appState","args","resUseCommand","useCommand","bind","useCommandExt","componentDidMount","ctc","context","command","Promise","res","console","log","setState","seeValue","value","valueChanged","user","render","contextType"],"mappings":";AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAO,KAAKC,OAAZ,MAAyB,4BAAzB;AAEA,SAASC,OAAT,QAAwB,eAAxB;AAEA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,IAAN,SAAmBJ,SAAnB,CAA6B;AAEhC;AAGAK,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,KAAL,GAAa;AACTC,MAAAA,QAAQ,EAAE,EADD;AAETC,MAAAA,IAAI,EAAE,EAFG;AAGTC,MAAAA,aAAa,EAAE;AAHN,KAAb;AAMA,SAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAAlB;AACA,SAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBD,IAAnB,CAAwB,IAAxB,CAArB;AACH;;AAEDE,EAAAA,iBAAiB,GAAG;AAChB;AACA;AACA,UAAM,QAAaC,GAAb,IAAqB,KAAKC,OAAhC;AACAd,IAAAA,OAAO,CAACE,IAAR,CAAaW,GAAG,CAAC,CAAD,CAAhB,EAAqB,IAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAVJ,UAAU,GAAG;AACf,UAAMM,OAAO,GAAG,MAAM,IAAIC,OAAJ,CAAYC,GAAG,IAAI;AACrCC,MAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ;AACA,WAAKC,QAAL,CAAc;AACVd,QAAAA,QAAQ,EAAE,YADA;AAEVE,QAAAA,aAAa,EAAES;AAFL,OAAd;AAIH,KANqB,CAAtB;AAOAC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,OAAZ;AACA,WAAOA,OAAP;AACH;;AACDJ,EAAAA,aAAa,CAACI,OAAD,EAAU;AACnBG,IAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACA,SAAKd,KAAL,CAAWG,aAAX,CAAyBO,OAAzB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,QAARM,QAAQ,CAACC,KAAD,EAAQ;AAClB,SAAKF,QAAL,CAAc;AACVd,MAAAA,QAAQ,EAAE,UADA;AAEVC,MAAAA,IAAI,EAAE,CAACe,KAAD;AAFI,KAAd;AAIH;;AAEiB,QAAZC,YAAY,CAACD,KAAD,EAAQE,IAAR,EAAc;AAC5B,SAAKJ,QAAL,CAAc;AACVd,MAAAA,QAAQ,EAAE,iBADA;AAEVC,MAAAA,IAAI,EAAE,CAACe,KAAD,EAAQE,IAAR;AAFI,KAAd;AAIH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,MAAM,GAAG;AACL,wBAAQ,QAAC,SAAD;AACJ,MAAA,QAAQ,EAAE,KAAKpB,KAAL,CAAWC,QADjB;AAEJ,MAAA,IAAI,EAAE,KAAKD,KAAL,CAAWE,IAFb;AAGJ,MAAA,eAAe,EAAE,KAAKF,KAAL,CAAWG,aAAX,IAA4B,IAHzC;AAIJ,MAAA,UAAU,EAAE,KAAKG;AAJb;AAAA;AAAA;AAAA;AAAA,YAAR;AAKH;;AAvG+B;AAAvBT,I,CAGFwB,W,GAAczB,O","sourcesContent":["import { Component } from \"react\";\nimport UserViews from \"./UserViews\";\nimport * as Backend from \"../../build/index.main.mjs\";\n\nimport { Context } from \"../../Context\";\n\n/**\n * @dev Buradaki User benim yazmış olduğum reachStorage kontratındaki bir\n * katılımcı. Sizin de yazdığınız kontratlardaki katılımcılara göre birden\n * fazla bu şekilde class bulundurmanız gerekli. \n */\nexport class User extends Component {\n\n    // Context'te tutulan bilgileri al.\n    static contextType = Context;\n\n    constructor(props) {\n        super(props);\n\n        /**\n         * @dev Kullanıcıdan her input bekleyişimizde bir Promise yapısı \n         * kullanacağımızdan her değer isteyen kontrat fonksiyonu için bir resolve\n         * fonksiyonunun state'de bulunması gerekli.\n         * \n         * @param appState: Kontratın hangi fonksiyonu çağırdığını gösterir\n         * @param args: Bu fonksiyonu çağırırken gönderilen argümanlar\n         * @param resUseCommand: useCommand appState'inin resolve fonksiyonu\n         */\n        this.state = {\n            appState: \"\",\n            args: [],\n            resUseCommand: null\n        }\n\n        this.useCommand = this.useCommand.bind(this);\n        this.useCommandExt = this.useCommandExt.bind(this);\n    }\n\n    componentDidMount() {\n        // Kontratı Context'ten al ve kontrattaki User'ın bu class\n        // olduğunu belirt.\n        const [, , , , , , ctc,] = this.context;\n        Backend.User(ctc[0], this);\n    }\n\n    /**\n     * @dev Burada bir Promise örüntüsü kullanılmakta.\n     * Reach useCommand fonksiyonunu dışarıdan çağırdığında veri girişi\n     * olana kadar bir şey döndürmemek istiyoruz.\n     * \n     * Bu yüzden de await new Promise() ile fonksiyonu bir nevi donduruyoruz.\n     * new Promise(resolve => {...}) şeklinde yazılan bir fonksiyondan değer\n     * dönmesi için resolve'un çağırılması gerekli.\n     * \n     * Bunun için de resolve'u state'e yükleyerek UserViews'a aktarıyoruz ve\n     * orada kullanıcıdan input alarak resolve'u çağırıyoruz.\n     * \n     * Burada useCommand Reach'in çağıracağı kontratta belirlenen fonksiyon\n     * useCommandExt de bizim resolve'u tetiklemek için çağıracağımız fonksiyon.\n     * \n     * O yüzden useCommand state'e gidecek, useCommandExt de UserViews'a\n     * \n     */\n    async useCommand() {\n        const command = await new Promise(res => {\n            console.log(\"useCommand is called\");\n            this.setState({\n                appState: \"useCommand\",\n                resUseCommand: res\n            });\n        });\n        console.log(command);\n        return command;\n    }\n    useCommandExt(command) {\n        console.log(\"useCommandExt is called\");\n        this.state.resUseCommand(command);\n    }\n\n    /**\n     * \n     * @param {int} value Reach'in seeValue'yu çağırırken bize \n     * vereceği değer\n     * \n     * Eğer bizden input beklemeyen bir fonksiyon varsa doğrudan\n     * appState'i değiştirmemiz ve gelen argümanları state'de\n     * args listesinde eklememiz yeterli. \n     */\n    async seeValue(value) {\n        this.setState({\n            appState: \"seeValue\",\n            args: [value]\n        });\n    }\n\n    async valueChanged(value, user) {\n        this.setState({\n            appState: \"seeValueChanged\",\n            args: [value, user]\n        });\n    }\n\n    /**\n     * \n     * @dev UserViews gelen appState değerine göre farklı bir view döndürmeli\n     * Her input bekleyen Reach fonksiyonu için bir ready boolean'ı ve bir\n     * de onu resolve'u çağıran bir fonksiyon UserViews'a yollanmalı \n     */\n    render() {\n        return (<UserViews\n            appState={this.state.appState}\n            args={this.state.args}\n            useCommandReady={this.state.resUseCommand != null}\n            useCommand={this.useCommandExt} />);\n    }\n}"]},"metadata":{},"sourceType":"module"}